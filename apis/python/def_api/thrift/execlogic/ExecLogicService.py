#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    Execution Service: Handles all Programs, Jobs and Tasks.
    """
    def getAllPrograms(self, userId):
        """
        Returns all program ids which are accessable by given user id.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - userId
        """
        pass

    def createProgram(self, clusterId, userId):
        """
        Request the creation of a new Program on a specified Cluster (clusterId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - clusterId
         - userId
        """
        pass

    def getProgram(self, pId):
        """
        Returns info about Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        pass

    def deleteProgram(self, pId):
        """
        Delete existing Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        pass

    def abortProgram(self, pId):
        """
        Abort running Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        pass

    def updateProgramName(self, pId, name):
        """
        Update name of Programm (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.


        Parameters:
         - pId
         - name
        """
        pass

    def updateProgramDescription(self, pId, description):
        """
        Update description of Programm (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.


        Parameters:
         - pId
         - description
        """
        pass

    def markProgramAsFinished(self, pId):
        """
        Mark Program (pId) as finished.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        pass

    def getAllJobs(self, pId):
        """
        Request the list of Jobs (jId) for a given Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        pass

    def createJob(self, pId):
        """
        Request the creation of a new Job on a specified Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        pass

    def getJob(self, pId, jId):
        """
        Requests info about specific Job given by Program Id (pId) and Job Id (jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        pass

    def deleteJob(self, pId, jId):
        """
        Requests deletion of a specific Job given by Program Id (pId) and Job Id (jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        pass

    def getAttachedMapRoutine(self, pId, jId):
        """
        Request the MapRoutine which is attached to the specified Job by Program Id (pId) and Job Id (jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        pass

    def attachMapRoutine(self, pId, jId, mapRoutineId):
        """
        Attaches a MapRoutine (mapRoutineId) to an Job (specified by pId and jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - mapRoutineId
        """
        pass

    def getAttachedReduceRoutine(self, pId, jId):
        """
        Returns attached ReduceRoutine (rlId) of the requested Program (pId) and Job (jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        pass

    def attachReduceRoutine(self, pId, jId, reduceRoutineId):
        """
        Attaches a ReduceRoutine (rlId) to an Job (specified by pId and jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - reduceRoutineId
        """
        pass

    def getAllTasks(self, pId, jId, sortingCriterion):
        """
        Requests a list of all Tasks (tId) for a given Program (pId) and Job (jId) sorted by the given sorting criterion.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.


        Parameters:
         - pId
         - jId
         - sortingCriterion
        """
        pass

    def getAllTasksWithState(self, pId, jId, state, sortingCriterion):
        """
        Requests a list of Tasks (tId) matching with the given etate for a given Program (pId) and Job (jId) sorted by the given sorting criterion.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - state
         - sortingCriterion
        """
        pass

    def createTask(self, pId, jId, objectiveRoutine):
        """
        Request the creation of a new Task on a specified Program (pId) and Job (jId) using
        given Routine Instance (= Routine Id with Parameters)
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - objectiveRoutine
        """
        pass

    def getTask(self, pId, jId, tId):
        """
        Returns info about Task by a combination of Program (pId), Job (jId) and Task (tId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - tId
        """
        pass

    def getTaskPartial(self, pId, jId, tId, includeInParameters, includeOutParameters):
        """
        Returns info about Task by a combination of Program (pId), Job (jId) and Task (tId).
        Includes in- and/or out-resources (parameter) if set.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - tId
         - includeInParameters
         - includeOutParameters
        """
        pass

    def markJobAsComplete(self, pId, jId):
        """
        Mark the given Job (jId) on Program (pId) as complete. This means all Tasks are created.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        pass

    def abortJob(self, pId, jId):
        """
        Abort Job (jId) on Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        pass

    def abortTask(self, pId, jId, tId):
        """
        Abort a running Task (tId) on a specified Job (jId) and Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - tId
        """
        pass

    def reRunTask(self, pId, jId, tId):
        """
        Re run a given Task (tId). This Task must be at state FAILED or SUCCESS.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.


        Parameters:
         - pId
         - jId
         - tId
        """
        pass

    def getAllSharedResources(self, pId):
        """
        Request a list of all SharedResources of a Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        pass

    def createSharedResource(self, pId, dataTypeId, data):
        """
        Request the creation of a new SharedResource on a specified Program (pId) of a given DatyType (dataType) and data.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - dataTypeId
         - data
        """
        pass

    def getSharedResource(self, pId, rId):
        """
        Request the SharedResource by a combination of Program (pId) and SharedResource (rId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - rId
        """
        pass

    def deleteSharedResource(self, pId, rId):
        """
        Request the deletion of a SharedResource by a combination of Program (pId) and SharedResource (rId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - rId
        """
        pass


class Client(Iface):
    """
    Execution Service: Handles all Programs, Jobs and Tasks.
    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def getAllPrograms(self, userId):
        """
        Returns all program ids which are accessable by given user id.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - userId
        """
        self.send_getAllPrograms(userId)
        return self.recv_getAllPrograms()

    def send_getAllPrograms(self, userId):
        self._oprot.writeMessageBegin('getAllPrograms', TMessageType.CALL, self._seqid)
        args = getAllPrograms_args()
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllPrograms(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllPrograms_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllPrograms failed: unknown result")

    def createProgram(self, clusterId, userId):
        """
        Request the creation of a new Program on a specified Cluster (clusterId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - clusterId
         - userId
        """
        self.send_createProgram(clusterId, userId)
        return self.recv_createProgram()

    def send_createProgram(self, clusterId, userId):
        self._oprot.writeMessageBegin('createProgram', TMessageType.CALL, self._seqid)
        args = createProgram_args()
        args.clusterId = clusterId
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createProgram(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createProgram_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createProgram failed: unknown result")

    def getProgram(self, pId):
        """
        Returns info about Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        self.send_getProgram(pId)
        return self.recv_getProgram()

    def send_getProgram(self, pId):
        self._oprot.writeMessageBegin('getProgram', TMessageType.CALL, self._seqid)
        args = getProgram_args()
        args.pId = pId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getProgram(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getProgram_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getProgram failed: unknown result")

    def deleteProgram(self, pId):
        """
        Delete existing Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        self.send_deleteProgram(pId)
        return self.recv_deleteProgram()

    def send_deleteProgram(self, pId):
        self._oprot.writeMessageBegin('deleteProgram', TMessageType.CALL, self._seqid)
        args = deleteProgram_args()
        args.pId = pId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteProgram(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteProgram_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteProgram failed: unknown result")

    def abortProgram(self, pId):
        """
        Abort running Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        self.send_abortProgram(pId)
        return self.recv_abortProgram()

    def send_abortProgram(self, pId):
        self._oprot.writeMessageBegin('abortProgram', TMessageType.CALL, self._seqid)
        args = abortProgram_args()
        args.pId = pId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abortProgram(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abortProgram_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "abortProgram failed: unknown result")

    def updateProgramName(self, pId, name):
        """
        Update name of Programm (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.


        Parameters:
         - pId
         - name
        """
        self.send_updateProgramName(pId, name)
        return self.recv_updateProgramName()

    def send_updateProgramName(self, pId, name):
        self._oprot.writeMessageBegin('updateProgramName', TMessageType.CALL, self._seqid)
        args = updateProgramName_args()
        args.pId = pId
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateProgramName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateProgramName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateProgramName failed: unknown result")

    def updateProgramDescription(self, pId, description):
        """
        Update description of Programm (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.


        Parameters:
         - pId
         - description
        """
        self.send_updateProgramDescription(pId, description)
        return self.recv_updateProgramDescription()

    def send_updateProgramDescription(self, pId, description):
        self._oprot.writeMessageBegin('updateProgramDescription', TMessageType.CALL, self._seqid)
        args = updateProgramDescription_args()
        args.pId = pId
        args.description = description
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateProgramDescription(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateProgramDescription_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateProgramDescription failed: unknown result")

    def markProgramAsFinished(self, pId):
        """
        Mark Program (pId) as finished.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        self.send_markProgramAsFinished(pId)
        return self.recv_markProgramAsFinished()

    def send_markProgramAsFinished(self, pId):
        self._oprot.writeMessageBegin('markProgramAsFinished', TMessageType.CALL, self._seqid)
        args = markProgramAsFinished_args()
        args.pId = pId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_markProgramAsFinished(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = markProgramAsFinished_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "markProgramAsFinished failed: unknown result")

    def getAllJobs(self, pId):
        """
        Request the list of Jobs (jId) for a given Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        self.send_getAllJobs(pId)
        return self.recv_getAllJobs()

    def send_getAllJobs(self, pId):
        self._oprot.writeMessageBegin('getAllJobs', TMessageType.CALL, self._seqid)
        args = getAllJobs_args()
        args.pId = pId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllJobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllJobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllJobs failed: unknown result")

    def createJob(self, pId):
        """
        Request the creation of a new Job on a specified Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        self.send_createJob(pId)
        return self.recv_createJob()

    def send_createJob(self, pId):
        self._oprot.writeMessageBegin('createJob', TMessageType.CALL, self._seqid)
        args = createJob_args()
        args.pId = pId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createJob(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createJob_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createJob failed: unknown result")

    def getJob(self, pId, jId):
        """
        Requests info about specific Job given by Program Id (pId) and Job Id (jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        self.send_getJob(pId, jId)
        return self.recv_getJob()

    def send_getJob(self, pId, jId):
        self._oprot.writeMessageBegin('getJob', TMessageType.CALL, self._seqid)
        args = getJob_args()
        args.pId = pId
        args.jId = jId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getJob(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getJob_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getJob failed: unknown result")

    def deleteJob(self, pId, jId):
        """
        Requests deletion of a specific Job given by Program Id (pId) and Job Id (jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        self.send_deleteJob(pId, jId)
        return self.recv_deleteJob()

    def send_deleteJob(self, pId, jId):
        self._oprot.writeMessageBegin('deleteJob', TMessageType.CALL, self._seqid)
        args = deleteJob_args()
        args.pId = pId
        args.jId = jId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteJob(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteJob_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteJob failed: unknown result")

    def getAttachedMapRoutine(self, pId, jId):
        """
        Request the MapRoutine which is attached to the specified Job by Program Id (pId) and Job Id (jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        self.send_getAttachedMapRoutine(pId, jId)
        return self.recv_getAttachedMapRoutine()

    def send_getAttachedMapRoutine(self, pId, jId):
        self._oprot.writeMessageBegin('getAttachedMapRoutine', TMessageType.CALL, self._seqid)
        args = getAttachedMapRoutine_args()
        args.pId = pId
        args.jId = jId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAttachedMapRoutine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAttachedMapRoutine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAttachedMapRoutine failed: unknown result")

    def attachMapRoutine(self, pId, jId, mapRoutineId):
        """
        Attaches a MapRoutine (mapRoutineId) to an Job (specified by pId and jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - mapRoutineId
        """
        self.send_attachMapRoutine(pId, jId, mapRoutineId)
        return self.recv_attachMapRoutine()

    def send_attachMapRoutine(self, pId, jId, mapRoutineId):
        self._oprot.writeMessageBegin('attachMapRoutine', TMessageType.CALL, self._seqid)
        args = attachMapRoutine_args()
        args.pId = pId
        args.jId = jId
        args.mapRoutineId = mapRoutineId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_attachMapRoutine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = attachMapRoutine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "attachMapRoutine failed: unknown result")

    def getAttachedReduceRoutine(self, pId, jId):
        """
        Returns attached ReduceRoutine (rlId) of the requested Program (pId) and Job (jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        self.send_getAttachedReduceRoutine(pId, jId)
        return self.recv_getAttachedReduceRoutine()

    def send_getAttachedReduceRoutine(self, pId, jId):
        self._oprot.writeMessageBegin('getAttachedReduceRoutine', TMessageType.CALL, self._seqid)
        args = getAttachedReduceRoutine_args()
        args.pId = pId
        args.jId = jId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAttachedReduceRoutine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAttachedReduceRoutine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAttachedReduceRoutine failed: unknown result")

    def attachReduceRoutine(self, pId, jId, reduceRoutineId):
        """
        Attaches a ReduceRoutine (rlId) to an Job (specified by pId and jId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - reduceRoutineId
        """
        self.send_attachReduceRoutine(pId, jId, reduceRoutineId)
        return self.recv_attachReduceRoutine()

    def send_attachReduceRoutine(self, pId, jId, reduceRoutineId):
        self._oprot.writeMessageBegin('attachReduceRoutine', TMessageType.CALL, self._seqid)
        args = attachReduceRoutine_args()
        args.pId = pId
        args.jId = jId
        args.reduceRoutineId = reduceRoutineId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_attachReduceRoutine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = attachReduceRoutine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "attachReduceRoutine failed: unknown result")

    def getAllTasks(self, pId, jId, sortingCriterion):
        """
        Requests a list of all Tasks (tId) for a given Program (pId) and Job (jId) sorted by the given sorting criterion.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.


        Parameters:
         - pId
         - jId
         - sortingCriterion
        """
        self.send_getAllTasks(pId, jId, sortingCriterion)
        return self.recv_getAllTasks()

    def send_getAllTasks(self, pId, jId, sortingCriterion):
        self._oprot.writeMessageBegin('getAllTasks', TMessageType.CALL, self._seqid)
        args = getAllTasks_args()
        args.pId = pId
        args.jId = jId
        args.sortingCriterion = sortingCriterion
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllTasks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllTasks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllTasks failed: unknown result")

    def getAllTasksWithState(self, pId, jId, state, sortingCriterion):
        """
        Requests a list of Tasks (tId) matching with the given etate for a given Program (pId) and Job (jId) sorted by the given sorting criterion.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - state
         - sortingCriterion
        """
        self.send_getAllTasksWithState(pId, jId, state, sortingCriterion)
        return self.recv_getAllTasksWithState()

    def send_getAllTasksWithState(self, pId, jId, state, sortingCriterion):
        self._oprot.writeMessageBegin('getAllTasksWithState', TMessageType.CALL, self._seqid)
        args = getAllTasksWithState_args()
        args.pId = pId
        args.jId = jId
        args.state = state
        args.sortingCriterion = sortingCriterion
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllTasksWithState(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllTasksWithState_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllTasksWithState failed: unknown result")

    def createTask(self, pId, jId, objectiveRoutine):
        """
        Request the creation of a new Task on a specified Program (pId) and Job (jId) using
        given Routine Instance (= Routine Id with Parameters)
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - objectiveRoutine
        """
        self.send_createTask(pId, jId, objectiveRoutine)
        return self.recv_createTask()

    def send_createTask(self, pId, jId, objectiveRoutine):
        self._oprot.writeMessageBegin('createTask', TMessageType.CALL, self._seqid)
        args = createTask_args()
        args.pId = pId
        args.jId = jId
        args.objectiveRoutine = objectiveRoutine
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createTask(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createTask_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createTask failed: unknown result")

    def getTask(self, pId, jId, tId):
        """
        Returns info about Task by a combination of Program (pId), Job (jId) and Task (tId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - tId
        """
        self.send_getTask(pId, jId, tId)
        return self.recv_getTask()

    def send_getTask(self, pId, jId, tId):
        self._oprot.writeMessageBegin('getTask', TMessageType.CALL, self._seqid)
        args = getTask_args()
        args.pId = pId
        args.jId = jId
        args.tId = tId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTask(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTask_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTask failed: unknown result")

    def getTaskPartial(self, pId, jId, tId, includeInParameters, includeOutParameters):
        """
        Returns info about Task by a combination of Program (pId), Job (jId) and Task (tId).
        Includes in- and/or out-resources (parameter) if set.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - tId
         - includeInParameters
         - includeOutParameters
        """
        self.send_getTaskPartial(pId, jId, tId, includeInParameters, includeOutParameters)
        return self.recv_getTaskPartial()

    def send_getTaskPartial(self, pId, jId, tId, includeInParameters, includeOutParameters):
        self._oprot.writeMessageBegin('getTaskPartial', TMessageType.CALL, self._seqid)
        args = getTaskPartial_args()
        args.pId = pId
        args.jId = jId
        args.tId = tId
        args.includeInParameters = includeInParameters
        args.includeOutParameters = includeOutParameters
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTaskPartial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTaskPartial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTaskPartial failed: unknown result")

    def markJobAsComplete(self, pId, jId):
        """
        Mark the given Job (jId) on Program (pId) as complete. This means all Tasks are created.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        self.send_markJobAsComplete(pId, jId)
        return self.recv_markJobAsComplete()

    def send_markJobAsComplete(self, pId, jId):
        self._oprot.writeMessageBegin('markJobAsComplete', TMessageType.CALL, self._seqid)
        args = markJobAsComplete_args()
        args.pId = pId
        args.jId = jId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_markJobAsComplete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = markJobAsComplete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "markJobAsComplete failed: unknown result")

    def abortJob(self, pId, jId):
        """
        Abort Job (jId) on Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
        """
        self.send_abortJob(pId, jId)
        return self.recv_abortJob()

    def send_abortJob(self, pId, jId):
        self._oprot.writeMessageBegin('abortJob', TMessageType.CALL, self._seqid)
        args = abortJob_args()
        args.pId = pId
        args.jId = jId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abortJob(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abortJob_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "abortJob failed: unknown result")

    def abortTask(self, pId, jId, tId):
        """
        Abort a running Task (tId) on a specified Job (jId) and Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - jId
         - tId
        """
        self.send_abortTask(pId, jId, tId)
        return self.recv_abortTask()

    def send_abortTask(self, pId, jId, tId):
        self._oprot.writeMessageBegin('abortTask', TMessageType.CALL, self._seqid)
        args = abortTask_args()
        args.pId = pId
        args.jId = jId
        args.tId = tId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abortTask(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abortTask_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "abortTask failed: unknown result")

    def reRunTask(self, pId, jId, tId):
        """
        Re run a given Task (tId). This Task must be at state FAILED or SUCCESS.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.


        Parameters:
         - pId
         - jId
         - tId
        """
        self.send_reRunTask(pId, jId, tId)
        return self.recv_reRunTask()

    def send_reRunTask(self, pId, jId, tId):
        self._oprot.writeMessageBegin('reRunTask', TMessageType.CALL, self._seqid)
        args = reRunTask_args()
        args.pId = pId
        args.jId = jId
        args.tId = tId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reRunTask(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reRunTask_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "reRunTask failed: unknown result")

    def getAllSharedResources(self, pId):
        """
        Request a list of all SharedResources of a Program (pId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
        """
        self.send_getAllSharedResources(pId)
        return self.recv_getAllSharedResources()

    def send_getAllSharedResources(self, pId):
        self._oprot.writeMessageBegin('getAllSharedResources', TMessageType.CALL, self._seqid)
        args = getAllSharedResources_args()
        args.pId = pId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllSharedResources(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllSharedResources_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllSharedResources failed: unknown result")

    def createSharedResource(self, pId, dataTypeId, data):
        """
        Request the creation of a new SharedResource on a specified Program (pId) of a given DatyType (dataType) and data.
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - dataTypeId
         - data
        """
        self.send_createSharedResource(pId, dataTypeId, data)
        return self.recv_createSharedResource()

    def send_createSharedResource(self, pId, dataTypeId, data):
        self._oprot.writeMessageBegin('createSharedResource', TMessageType.CALL, self._seqid)
        args = createSharedResource_args()
        args.pId = pId
        args.dataTypeId = dataTypeId
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createSharedResource(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createSharedResource_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createSharedResource failed: unknown result")

    def getSharedResource(self, pId, rId):
        """
        Request the SharedResource by a combination of Program (pId) and SharedResource (rId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - rId
        """
        self.send_getSharedResource(pId, rId)
        return self.recv_getSharedResource()

    def send_getSharedResource(self, pId, rId):
        self._oprot.writeMessageBegin('getSharedResource', TMessageType.CALL, self._seqid)
        args = getSharedResource_args()
        args.pId = pId
        args.rId = rId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSharedResource(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSharedResource_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSharedResource failed: unknown result")

    def deleteSharedResource(self, pId, rId):
        """
        Request the deletion of a SharedResource by a combination of Program (pId) and SharedResource (rId).
        Returns a ticket id, state of ticket is available over TicketService interface, real result over Response interface.

        Parameters:
         - pId
         - rId
        """
        self.send_deleteSharedResource(pId, rId)
        return self.recv_deleteSharedResource()

    def send_deleteSharedResource(self, pId, rId):
        self._oprot.writeMessageBegin('deleteSharedResource', TMessageType.CALL, self._seqid)
        args = deleteSharedResource_args()
        args.pId = pId
        args.rId = rId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteSharedResource(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteSharedResource_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteSharedResource failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["getAllPrograms"] = Processor.process_getAllPrograms
        self._processMap["createProgram"] = Processor.process_createProgram
        self._processMap["getProgram"] = Processor.process_getProgram
        self._processMap["deleteProgram"] = Processor.process_deleteProgram
        self._processMap["abortProgram"] = Processor.process_abortProgram
        self._processMap["updateProgramName"] = Processor.process_updateProgramName
        self._processMap["updateProgramDescription"] = Processor.process_updateProgramDescription
        self._processMap["markProgramAsFinished"] = Processor.process_markProgramAsFinished
        self._processMap["getAllJobs"] = Processor.process_getAllJobs
        self._processMap["createJob"] = Processor.process_createJob
        self._processMap["getJob"] = Processor.process_getJob
        self._processMap["deleteJob"] = Processor.process_deleteJob
        self._processMap["getAttachedMapRoutine"] = Processor.process_getAttachedMapRoutine
        self._processMap["attachMapRoutine"] = Processor.process_attachMapRoutine
        self._processMap["getAttachedReduceRoutine"] = Processor.process_getAttachedReduceRoutine
        self._processMap["attachReduceRoutine"] = Processor.process_attachReduceRoutine
        self._processMap["getAllTasks"] = Processor.process_getAllTasks
        self._processMap["getAllTasksWithState"] = Processor.process_getAllTasksWithState
        self._processMap["createTask"] = Processor.process_createTask
        self._processMap["getTask"] = Processor.process_getTask
        self._processMap["getTaskPartial"] = Processor.process_getTaskPartial
        self._processMap["markJobAsComplete"] = Processor.process_markJobAsComplete
        self._processMap["abortJob"] = Processor.process_abortJob
        self._processMap["abortTask"] = Processor.process_abortTask
        self._processMap["reRunTask"] = Processor.process_reRunTask
        self._processMap["getAllSharedResources"] = Processor.process_getAllSharedResources
        self._processMap["createSharedResource"] = Processor.process_createSharedResource
        self._processMap["getSharedResource"] = Processor.process_getSharedResource
        self._processMap["deleteSharedResource"] = Processor.process_deleteSharedResource

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getAllPrograms(self, seqid, iprot, oprot):
        args = getAllPrograms_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllPrograms_result()
        try:
            result.success = self._handler.getAllPrograms(args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllPrograms", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createProgram(self, seqid, iprot, oprot):
        args = createProgram_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createProgram_result()
        try:
            result.success = self._handler.createProgram(args.clusterId, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createProgram", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getProgram(self, seqid, iprot, oprot):
        args = getProgram_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getProgram_result()
        try:
            result.success = self._handler.getProgram(args.pId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getProgram", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteProgram(self, seqid, iprot, oprot):
        args = deleteProgram_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteProgram_result()
        try:
            result.success = self._handler.deleteProgram(args.pId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteProgram", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abortProgram(self, seqid, iprot, oprot):
        args = abortProgram_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abortProgram_result()
        try:
            result.success = self._handler.abortProgram(args.pId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("abortProgram", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateProgramName(self, seqid, iprot, oprot):
        args = updateProgramName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateProgramName_result()
        try:
            result.success = self._handler.updateProgramName(args.pId, args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateProgramName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateProgramDescription(self, seqid, iprot, oprot):
        args = updateProgramDescription_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateProgramDescription_result()
        try:
            result.success = self._handler.updateProgramDescription(args.pId, args.description)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateProgramDescription", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_markProgramAsFinished(self, seqid, iprot, oprot):
        args = markProgramAsFinished_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = markProgramAsFinished_result()
        try:
            result.success = self._handler.markProgramAsFinished(args.pId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("markProgramAsFinished", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllJobs(self, seqid, iprot, oprot):
        args = getAllJobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllJobs_result()
        try:
            result.success = self._handler.getAllJobs(args.pId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllJobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createJob(self, seqid, iprot, oprot):
        args = createJob_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createJob_result()
        try:
            result.success = self._handler.createJob(args.pId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createJob", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getJob(self, seqid, iprot, oprot):
        args = getJob_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getJob_result()
        try:
            result.success = self._handler.getJob(args.pId, args.jId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getJob", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteJob(self, seqid, iprot, oprot):
        args = deleteJob_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteJob_result()
        try:
            result.success = self._handler.deleteJob(args.pId, args.jId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteJob", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAttachedMapRoutine(self, seqid, iprot, oprot):
        args = getAttachedMapRoutine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAttachedMapRoutine_result()
        try:
            result.success = self._handler.getAttachedMapRoutine(args.pId, args.jId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAttachedMapRoutine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_attachMapRoutine(self, seqid, iprot, oprot):
        args = attachMapRoutine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = attachMapRoutine_result()
        try:
            result.success = self._handler.attachMapRoutine(args.pId, args.jId, args.mapRoutineId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("attachMapRoutine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAttachedReduceRoutine(self, seqid, iprot, oprot):
        args = getAttachedReduceRoutine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAttachedReduceRoutine_result()
        try:
            result.success = self._handler.getAttachedReduceRoutine(args.pId, args.jId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAttachedReduceRoutine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_attachReduceRoutine(self, seqid, iprot, oprot):
        args = attachReduceRoutine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = attachReduceRoutine_result()
        try:
            result.success = self._handler.attachReduceRoutine(args.pId, args.jId, args.reduceRoutineId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("attachReduceRoutine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllTasks(self, seqid, iprot, oprot):
        args = getAllTasks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllTasks_result()
        try:
            result.success = self._handler.getAllTasks(args.pId, args.jId, args.sortingCriterion)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllTasks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllTasksWithState(self, seqid, iprot, oprot):
        args = getAllTasksWithState_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllTasksWithState_result()
        try:
            result.success = self._handler.getAllTasksWithState(args.pId, args.jId, args.state, args.sortingCriterion)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllTasksWithState", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createTask(self, seqid, iprot, oprot):
        args = createTask_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createTask_result()
        try:
            result.success = self._handler.createTask(args.pId, args.jId, args.objectiveRoutine)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createTask", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTask(self, seqid, iprot, oprot):
        args = getTask_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTask_result()
        try:
            result.success = self._handler.getTask(args.pId, args.jId, args.tId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTask", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTaskPartial(self, seqid, iprot, oprot):
        args = getTaskPartial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTaskPartial_result()
        try:
            result.success = self._handler.getTaskPartial(args.pId, args.jId, args.tId, args.includeInParameters, args.includeOutParameters)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTaskPartial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_markJobAsComplete(self, seqid, iprot, oprot):
        args = markJobAsComplete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = markJobAsComplete_result()
        try:
            result.success = self._handler.markJobAsComplete(args.pId, args.jId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("markJobAsComplete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abortJob(self, seqid, iprot, oprot):
        args = abortJob_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abortJob_result()
        try:
            result.success = self._handler.abortJob(args.pId, args.jId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("abortJob", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abortTask(self, seqid, iprot, oprot):
        args = abortTask_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abortTask_result()
        try:
            result.success = self._handler.abortTask(args.pId, args.jId, args.tId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("abortTask", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reRunTask(self, seqid, iprot, oprot):
        args = reRunTask_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reRunTask_result()
        try:
            result.success = self._handler.reRunTask(args.pId, args.jId, args.tId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reRunTask", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllSharedResources(self, seqid, iprot, oprot):
        args = getAllSharedResources_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllSharedResources_result()
        try:
            result.success = self._handler.getAllSharedResources(args.pId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllSharedResources", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createSharedResource(self, seqid, iprot, oprot):
        args = createSharedResource_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createSharedResource_result()
        try:
            result.success = self._handler.createSharedResource(args.pId, args.dataTypeId, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createSharedResource", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSharedResource(self, seqid, iprot, oprot):
        args = getSharedResource_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSharedResource_result()
        try:
            result.success = self._handler.getSharedResource(args.pId, args.rId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSharedResource", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteSharedResource(self, seqid, iprot, oprot):
        args = deleteSharedResource_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteSharedResource_result()
        try:
            result.success = self._handler.deleteSharedResource(args.pId, args.rId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteSharedResource", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getAllPrograms_args(object):
    """
    Attributes:
     - userId
    """


    def __init__(self, userId=None,):
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllPrograms_args')
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 1)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllPrograms_args)
getAllPrograms_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userId', 'UTF8', None, ),  # 1
)


class getAllPrograms_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllPrograms_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllPrograms_result)
getAllPrograms_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class createProgram_args(object):
    """
    Attributes:
     - clusterId
     - userId
    """


    def __init__(self, clusterId=None, userId=None,):
        self.clusterId = clusterId
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createProgram_args')
        if self.clusterId is not None:
            oprot.writeFieldBegin('clusterId', TType.STRING, 1)
            oprot.writeString(self.clusterId.encode('utf-8') if sys.version_info[0] == 2 else self.clusterId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createProgram_args)
createProgram_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
)


class createProgram_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createProgram_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createProgram_result)
createProgram_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getProgram_args(object):
    """
    Attributes:
     - pId
    """


    def __init__(self, pId=None,):
        self.pId = pId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProgram_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProgram_args)
getProgram_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
)


class getProgram_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getProgram_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getProgram_result)
getProgram_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class deleteProgram_args(object):
    """
    Attributes:
     - pId
    """


    def __init__(self, pId=None,):
        self.pId = pId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteProgram_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteProgram_args)
deleteProgram_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
)


class deleteProgram_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteProgram_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteProgram_result)
deleteProgram_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class abortProgram_args(object):
    """
    Attributes:
     - pId
    """


    def __init__(self, pId=None,):
        self.pId = pId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abortProgram_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abortProgram_args)
abortProgram_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
)


class abortProgram_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abortProgram_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abortProgram_result)
abortProgram_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class updateProgramName_args(object):
    """
    Attributes:
     - pId
     - name
    """


    def __init__(self, pId=None, name=None,):
        self.pId = pId
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateProgramName_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateProgramName_args)
updateProgramName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
)


class updateProgramName_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateProgramName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateProgramName_result)
updateProgramName_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class updateProgramDescription_args(object):
    """
    Attributes:
     - pId
     - description
    """


    def __init__(self, pId=None, description=None,):
        self.pId = pId
        self.description = description

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateProgramDescription_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 2)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateProgramDescription_args)
updateProgramDescription_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'description', 'UTF8', None, ),  # 2
)


class updateProgramDescription_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateProgramDescription_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateProgramDescription_result)
updateProgramDescription_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class markProgramAsFinished_args(object):
    """
    Attributes:
     - pId
    """


    def __init__(self, pId=None,):
        self.pId = pId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('markProgramAsFinished_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(markProgramAsFinished_args)
markProgramAsFinished_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
)


class markProgramAsFinished_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('markProgramAsFinished_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(markProgramAsFinished_result)
markProgramAsFinished_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAllJobs_args(object):
    """
    Attributes:
     - pId
    """


    def __init__(self, pId=None,):
        self.pId = pId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllJobs_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllJobs_args)
getAllJobs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
)


class getAllJobs_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllJobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllJobs_result)
getAllJobs_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class createJob_args(object):
    """
    Attributes:
     - pId
    """


    def __init__(self, pId=None,):
        self.pId = pId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createJob_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createJob_args)
createJob_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
)


class createJob_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createJob_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createJob_result)
createJob_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getJob_args(object):
    """
    Attributes:
     - pId
     - jId
    """


    def __init__(self, pId=None, jId=None,):
        self.pId = pId
        self.jId = jId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getJob_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getJob_args)
getJob_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
)


class getJob_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getJob_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getJob_result)
getJob_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class deleteJob_args(object):
    """
    Attributes:
     - pId
     - jId
    """


    def __init__(self, pId=None, jId=None,):
        self.pId = pId
        self.jId = jId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteJob_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteJob_args)
deleteJob_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
)


class deleteJob_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteJob_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteJob_result)
deleteJob_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAttachedMapRoutine_args(object):
    """
    Attributes:
     - pId
     - jId
    """


    def __init__(self, pId=None, jId=None,):
        self.pId = pId
        self.jId = jId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAttachedMapRoutine_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAttachedMapRoutine_args)
getAttachedMapRoutine_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
)


class getAttachedMapRoutine_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAttachedMapRoutine_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAttachedMapRoutine_result)
getAttachedMapRoutine_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class attachMapRoutine_args(object):
    """
    Attributes:
     - pId
     - jId
     - mapRoutineId
    """


    def __init__(self, pId=None, jId=None, mapRoutineId=None,):
        self.pId = pId
        self.jId = jId
        self.mapRoutineId = mapRoutineId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mapRoutineId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attachMapRoutine_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        if self.mapRoutineId is not None:
            oprot.writeFieldBegin('mapRoutineId', TType.STRING, 3)
            oprot.writeString(self.mapRoutineId.encode('utf-8') if sys.version_info[0] == 2 else self.mapRoutineId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attachMapRoutine_args)
attachMapRoutine_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mapRoutineId', 'UTF8', None, ),  # 3
)


class attachMapRoutine_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attachMapRoutine_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attachMapRoutine_result)
attachMapRoutine_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAttachedReduceRoutine_args(object):
    """
    Attributes:
     - pId
     - jId
    """


    def __init__(self, pId=None, jId=None,):
        self.pId = pId
        self.jId = jId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAttachedReduceRoutine_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAttachedReduceRoutine_args)
getAttachedReduceRoutine_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
)


class getAttachedReduceRoutine_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAttachedReduceRoutine_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAttachedReduceRoutine_result)
getAttachedReduceRoutine_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class attachReduceRoutine_args(object):
    """
    Attributes:
     - pId
     - jId
     - reduceRoutineId
    """


    def __init__(self, pId=None, jId=None, reduceRoutineId=None,):
        self.pId = pId
        self.jId = jId
        self.reduceRoutineId = reduceRoutineId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.reduceRoutineId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attachReduceRoutine_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        if self.reduceRoutineId is not None:
            oprot.writeFieldBegin('reduceRoutineId', TType.STRING, 3)
            oprot.writeString(self.reduceRoutineId.encode('utf-8') if sys.version_info[0] == 2 else self.reduceRoutineId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attachReduceRoutine_args)
attachReduceRoutine_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'reduceRoutineId', 'UTF8', None, ),  # 3
)


class attachReduceRoutine_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attachReduceRoutine_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attachReduceRoutine_result)
attachReduceRoutine_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAllTasks_args(object):
    """
    Attributes:
     - pId
     - jId
     - sortingCriterion
    """


    def __init__(self, pId=None, jId=None, sortingCriterion=None,):
        self.pId = pId
        self.jId = jId
        self.sortingCriterion = sortingCriterion

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.sortingCriterion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllTasks_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        if self.sortingCriterion is not None:
            oprot.writeFieldBegin('sortingCriterion', TType.I32, 3)
            oprot.writeI32(self.sortingCriterion)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllTasks_args)
getAllTasks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
    (3, TType.I32, 'sortingCriterion', None, None, ),  # 3
)


class getAllTasks_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllTasks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllTasks_result)
getAllTasks_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAllTasksWithState_args(object):
    """
    Attributes:
     - pId
     - jId
     - state
     - sortingCriterion
    """


    def __init__(self, pId=None, jId=None, state=None, sortingCriterion=None,):
        self.pId = pId
        self.jId = jId
        self.state = state
        self.sortingCriterion = sortingCriterion

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.sortingCriterion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllTasksWithState_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 3)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.sortingCriterion is not None:
            oprot.writeFieldBegin('sortingCriterion', TType.I32, 4)
            oprot.writeI32(self.sortingCriterion)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllTasksWithState_args)
getAllTasksWithState_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
    (3, TType.I32, 'state', None, None, ),  # 3
    (4, TType.I32, 'sortingCriterion', None, None, ),  # 4
)


class getAllTasksWithState_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllTasksWithState_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllTasksWithState_result)
getAllTasksWithState_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class createTask_args(object):
    """
    Attributes:
     - pId
     - jId
     - objectiveRoutine
    """


    def __init__(self, pId=None, jId=None, objectiveRoutine=None,):
        self.pId = pId
        self.jId = jId
        self.objectiveRoutine = objectiveRoutine

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.objectiveRoutine = def_api.thrift.transfer.ttypes.RoutineInstanceDTO()
                    self.objectiveRoutine.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createTask_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        if self.objectiveRoutine is not None:
            oprot.writeFieldBegin('objectiveRoutine', TType.STRUCT, 3)
            self.objectiveRoutine.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createTask_args)
createTask_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'objectiveRoutine', [def_api.thrift.transfer.ttypes.RoutineInstanceDTO, None], None, ),  # 3
)


class createTask_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createTask_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createTask_result)
createTask_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getTask_args(object):
    """
    Attributes:
     - pId
     - jId
     - tId
    """


    def __init__(self, pId=None, jId=None, tId=None,):
        self.pId = pId
        self.jId = jId
        self.tId = tId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTask_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        if self.tId is not None:
            oprot.writeFieldBegin('tId', TType.STRING, 3)
            oprot.writeString(self.tId.encode('utf-8') if sys.version_info[0] == 2 else self.tId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTask_args)
getTask_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tId', 'UTF8', None, ),  # 3
)


class getTask_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTask_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTask_result)
getTask_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getTaskPartial_args(object):
    """
    Attributes:
     - pId
     - jId
     - tId
     - includeInParameters
     - includeOutParameters
    """


    def __init__(self, pId=None, jId=None, tId=None, includeInParameters=None, includeOutParameters=None,):
        self.pId = pId
        self.jId = jId
        self.tId = tId
        self.includeInParameters = includeInParameters
        self.includeOutParameters = includeOutParameters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.includeInParameters = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.includeOutParameters = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTaskPartial_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        if self.tId is not None:
            oprot.writeFieldBegin('tId', TType.STRING, 3)
            oprot.writeString(self.tId.encode('utf-8') if sys.version_info[0] == 2 else self.tId)
            oprot.writeFieldEnd()
        if self.includeInParameters is not None:
            oprot.writeFieldBegin('includeInParameters', TType.BOOL, 4)
            oprot.writeBool(self.includeInParameters)
            oprot.writeFieldEnd()
        if self.includeOutParameters is not None:
            oprot.writeFieldBegin('includeOutParameters', TType.BOOL, 5)
            oprot.writeBool(self.includeOutParameters)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTaskPartial_args)
getTaskPartial_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tId', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'includeInParameters', None, None, ),  # 4
    (5, TType.BOOL, 'includeOutParameters', None, None, ),  # 5
)


class getTaskPartial_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTaskPartial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTaskPartial_result)
getTaskPartial_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class markJobAsComplete_args(object):
    """
    Attributes:
     - pId
     - jId
    """


    def __init__(self, pId=None, jId=None,):
        self.pId = pId
        self.jId = jId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('markJobAsComplete_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(markJobAsComplete_args)
markJobAsComplete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
)


class markJobAsComplete_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('markJobAsComplete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(markJobAsComplete_result)
markJobAsComplete_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class abortJob_args(object):
    """
    Attributes:
     - pId
     - jId
    """


    def __init__(self, pId=None, jId=None,):
        self.pId = pId
        self.jId = jId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abortJob_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abortJob_args)
abortJob_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
)


class abortJob_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abortJob_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abortJob_result)
abortJob_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class abortTask_args(object):
    """
    Attributes:
     - pId
     - jId
     - tId
    """


    def __init__(self, pId=None, jId=None, tId=None,):
        self.pId = pId
        self.jId = jId
        self.tId = tId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abortTask_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        if self.tId is not None:
            oprot.writeFieldBegin('tId', TType.STRING, 3)
            oprot.writeString(self.tId.encode('utf-8') if sys.version_info[0] == 2 else self.tId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abortTask_args)
abortTask_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tId', 'UTF8', None, ),  # 3
)


class abortTask_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abortTask_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abortTask_result)
abortTask_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class reRunTask_args(object):
    """
    Attributes:
     - pId
     - jId
     - tId
    """


    def __init__(self, pId=None, jId=None, tId=None,):
        self.pId = pId
        self.jId = jId
        self.tId = tId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reRunTask_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.jId is not None:
            oprot.writeFieldBegin('jId', TType.STRING, 2)
            oprot.writeString(self.jId.encode('utf-8') if sys.version_info[0] == 2 else self.jId)
            oprot.writeFieldEnd()
        if self.tId is not None:
            oprot.writeFieldBegin('tId', TType.STRING, 3)
            oprot.writeString(self.tId.encode('utf-8') if sys.version_info[0] == 2 else self.tId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reRunTask_args)
reRunTask_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'jId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'tId', 'UTF8', None, ),  # 3
)


class reRunTask_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reRunTask_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reRunTask_result)
reRunTask_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAllSharedResources_args(object):
    """
    Attributes:
     - pId
    """


    def __init__(self, pId=None,):
        self.pId = pId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllSharedResources_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllSharedResources_args)
getAllSharedResources_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
)


class getAllSharedResources_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllSharedResources_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllSharedResources_result)
getAllSharedResources_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class createSharedResource_args(object):
    """
    Attributes:
     - pId
     - dataTypeId
     - data
    """


    def __init__(self, pId=None, dataTypeId=None, data=None,):
        self.pId = pId
        self.dataTypeId = dataTypeId
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.dataTypeId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createSharedResource_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.dataTypeId is not None:
            oprot.writeFieldBegin('dataTypeId', TType.STRING, 2)
            oprot.writeString(self.dataTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.dataTypeId)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 3)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createSharedResource_args)
createSharedResource_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'dataTypeId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'data', 'BINARY', None, ),  # 3
)


class createSharedResource_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createSharedResource_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createSharedResource_result)
createSharedResource_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getSharedResource_args(object):
    """
    Attributes:
     - pId
     - rId
    """


    def __init__(self, pId=None, rId=None,):
        self.pId = pId
        self.rId = rId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.rId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSharedResource_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.rId is not None:
            oprot.writeFieldBegin('rId', TType.STRING, 2)
            oprot.writeString(self.rId.encode('utf-8') if sys.version_info[0] == 2 else self.rId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSharedResource_args)
getSharedResource_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'rId', 'UTF8', None, ),  # 2
)


class getSharedResource_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSharedResource_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSharedResource_result)
getSharedResource_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class deleteSharedResource_args(object):
    """
    Attributes:
     - pId
     - rId
    """


    def __init__(self, pId=None, rId=None,):
        self.pId = pId
        self.rId = rId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.rId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteSharedResource_args')
        if self.pId is not None:
            oprot.writeFieldBegin('pId', TType.STRING, 1)
            oprot.writeString(self.pId.encode('utf-8') if sys.version_info[0] == 2 else self.pId)
            oprot.writeFieldEnd()
        if self.rId is not None:
            oprot.writeFieldBegin('rId', TType.STRING, 2)
            oprot.writeString(self.rId.encode('utf-8') if sys.version_info[0] == 2 else self.rId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteSharedResource_args)
deleteSharedResource_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'rId', 'UTF8', None, ),  # 2
)


class deleteSharedResource_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteSharedResource_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteSharedResource_result)
deleteSharedResource_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)
fix_spec(all_structs)
del all_structs

